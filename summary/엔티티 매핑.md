<h2>@Entity</h2>
<ul>
  <li>@Entity가 붙은 클래스는 JPA가 관리, 엔티티라 한다.</li>
  <li>JPA를 사용해서 테이블과 매핑할 클래스는 @Entity 필수</li>
  <li>주의사항</li>
  <ul>
    <li>기본 생성자 필수(파라미터가 없는 public 또는 protected 생성자)</li>
    <li>final 클래스, enum, interface, inner 클래스 사용X</li>
    <li>저장할 필드에 final 사용 X</li>
  </ul>
</ul>
<h2>@Entity속성</h2>
<ul>
  <li>name</li>
  <ul>
    <li>JPA에서 사용할 엔티티 이름을 지정한다.</li>
    <li>기본값: 클래스 이름을 그대로 사용</li>
    <li>같은 클래스 이름이 없으면 가급적 기본값을 사용한다.</li>
  </ul>
</ul>
<h2>@Table</h2>
<ul>
  <li>@Table은 엔티티와 매핑할 테이블 지정</li>
</ul>
<table border="1">
  <tr>
    <th>속성</th>
    <th>기능</th>
    <th>기본값</th>
  </tr>
  <tr>
    <td>name</td>
    <td>매핑할 테이블 이름</td>
    <td>엔티티 이름을 사용</td>
  </tr>
  <tr>
    <td>catalog</td>
    <td>데이터베이스 catalog 매핑</td>
    <td></td>
  </tr>
  <tr>
    <td>schema</td>
    <td>데이터베이스 schema매핑</td>
    <td></td>
  </tr>
  <tr>
    <td>uniqueConstraints(DDL)</td>
    <td>DDL 생성 시에 유니크 제약 조건 생성</td>
    <td></td>
  </tr>
</table>
<h2>데이터베이스 스키마 자동 생성</h2>
<ul>
  <li>DDL을 애플리케이션 실행 시점에 자동 생성</li>
  <li>테이블 중심 -> 객체 중심</li>
  <li>데이터베이스 방언을 활용해서 데이터베이스에 맞는 적절한 DDL 생성</li>
  <li>이렇게 생성된 DDL은 개발 장비에서만 사용</li>
  <li>생성된 DDL은 운영서버에서는 사용하지 않거나, 적절히 다듬은 후 사용</li>
</ul>
<h4>hibernate.hbm2ddl.auto</h4>
<table>
  <tr>
    <th>옵션</th>
    <th>설명</th>
  </tr>
  <tr>
    <td>create</td>
    <td>기존테이블 삭제 후 다시 생성(DROP + CREATE)</td>
  </tr>
  <tr>
    <td>create-drop</td>
    <td>create와 같으나 종료시점에 테이블 DROP</td>
  </tr>
  <tr>
    <td>update</td>
    <td>변경분만 반영(운영DB에서 사용X)</td>
  </tr>
  <tr>
    <td>validate</td>
    <td>엔티티와 테이블이 정상 매핑되었는지만 확인</td>
  </tr>
  <tr>
    <td>none</td>
    <td>사용하지 않음</td>
  </tr>
</table>
<h4>데이터베이스 스키마 자동 생성 주의점</h4>
<ul>
  <li>운영 장비에는 절대 create, create-drop, update 사용하면 안된다.</li>
  <li>개발 초기 단계는 create 또는 update</li>
  <li>테스트 서버는 update 또는 validate</li>
  <li>스테이징과 운영 서버는 validate 또는 none</li>
</ul>
<h2>DDL 생성 기능</h2>
<ul>
  <li>제약조건 추가 : 회원 이름은 필수, 10자 초과 X ( @Column(nullble = false, length = 10) )</li>
  <li>유니크 제약조건 추가 ( @Table(uniqueConstraints = {@UniqueConstraint(name = "NAME_AGE_UNIQUE", columnNames = {"NAME","AGE"})}) )</li>
  <li>DDL 생성 기능은 DDL을 자동 생성할 때만 사용되고 JPA의 실행 로직에는 영향을 주지 않는다.</li>
</ul>
<h4>Ex</h4>
<pre>
@Entity 
public class Member { 

@Id 
private Long id; 
  
@Column(name = "name") 
private String username; 
private Integer age; 
  
@Enumerated(EnumType.STRING) 
private RoleType roleType; 
  
@Temporal(TemporalType.TIMESTAMP) 
private Date createdDate; 
  
@Temporal(TemporalType.TIMESTAMP) 
private Date lastModifiedDate; 
  
@Lob 
private String description;  
} 
</pre>
<h2>@Colum</h2>
<h4>컬럼 매핑</h4>
<img src="https://user-images.githubusercontent.com/76415175/111118052-a5a6b580-85ab-11eb-8f90-7c94027d12ca.PNG">
<h2>@Enumerated</h2>
<h4>자바 enum 타입을 매핑할 때 사용(ORDINAL 사용X)</h4>
<img src="https://user-images.githubusercontent.com/76415175/111118272-e1da1600-85ab-11eb-86d7-81cb2c1aaa1b.PNG">
<h2>@Temporal</h2>
<h4>날짜 타입을 매핑할 때 사용(LocalDate, LocalDateTime을 사용할땐 생략 가능)</h4>
<table>
  <tr>
    <th>속성</th>
    <th>설명</th>
  </tr>
  <tr>
    <td>value</td>
    <td>• TemporalType.DATE: 날짜, 데이터베이스 date 타입과 매핑(예: 2013–10–11) <br>
• TemporalType.TIME: 시간, 데이터베이스 time 타입과 매핑(예: 11:11:11) <br>
• TemporalType.TIMESTAMP: 날짜와 시간, 데이터베이스 timestamp 타입과 매핑(예: 2013–10–11 11:11:11)</td>
  </tr>
</table>
<h2>@Lob</h2>
<ul>
  <li>데이터베이스 BLOB, CLOB 타입과 매핑</li>
  <li>@Lob에는 지정할 수 있는 속성이 없다.</li>
  <li>매핑하는 필드 타입이 문자면 CLOB 매핑, 나머지는 BLOB 매핑</li>
  <li>CLOB: String, char[], java.sql.CLOB </li>
  <li>BLOB: byte[], java.sql. BLOB</li>
</ul>
<h2>@Transient</h2>
<ul>
  <li>필드 매핑X</li>
  <li>데이터베이스에 저장X, 조회X</li>
  <li>주로 메모리상에서만 임시로 어떤 값을 보관하고 싶을 때 사용</li>
  <li>@Transient<br>private Integer temp;</li>
</ul>
<h2>기본키 매핑 어노테이션</h2>
<ul>
  <li>@Id</li>
  <li>@GeneratedValue</li>
</ul>
<pre>
@Id @GeneratedValue(strategy = GenerationType.Auto)
private Long id;
</pre>
<h2>기본키 매핑 방법</h2>
<ul>
  <li>직접할당 : @Id만 사용</li>
  <li>자동생성(@GeneratedValue)</li>
  <ul>
    <li>IDENTITY: 데이터베이스에 위임, MYSQL</li>
    <li>SEQUENCE: 데이터베이스 시퀀스 오브젝트 사용, ORACLE (@SequenceGenerator 필요)</li>
    <li>TABLE: 키 생성용 테이블 사용, 모든 DB에서 사용(@TableGenerator 필요)</li>
    <li>AUTO: 방언에 따라 자동 지정, 기본값</li>
  </ul>
</ul>
<h2>IDENTITY 전략 - 특징</h2>
<ul>
  <li>기본 키 생성을 데이터베이스에 위임</li>
  <li>주로 MySQL, PostgreSQL, SQL Server, DB2에서 사용(예: MySQL의 AUTO_ INCREMENT) </li>
  <li>JPA는 보통 트랜잭션 커밋 시점에 INSERT SQL 실행</li>
  <li>AUTO_ INCREMENT는 데이터베이스에 INSERT SQL을 실행한 이후에 ID 값을 알 수 있음</li>
  <li>IDENTITY 전략은 em.persist() 시점에 즉시 INSERT SQL 실행하고 DB에서 식별자를 조회</li>
</ul>
<pre>
@Id @GeneratedValue(strategy = GenerationType.IDENTITY) 
private Long id;
</pre>
<h2>SEQUENCE 전략 - 특징</h2>
<ul>
  <li>데이터베이스 시퀀스는 유일한 값을 순서대로 생성하는 특별한 데이터베이스 오브젝트(예: 오라클 시퀀스)</li>
  <li>오라클, PostgreSQL, DB2, H2 데이터베이스에서 사용</li>
</ul>
<pre>
@Entity
@SequenceGenerator(name = “MEMBER_SEQ_GENERATOR",sequenceName = “MEMBER_SEQ",initialValue = 1, allocationSize = 1)//sequenceName = 매핑할 데이터베이스 시퀀스 이름
----
@Id 
@GeneratedValue(strategy = GenerationType.SEQUENCE,generator = "MEMBER_SEQ_GENERATOR")
private Long id;
</pre>
<h2>SEQUENCE - @SequenceGenerator</h2>
<img src="https://user-images.githubusercontent.com/76415175/111119552-9e80a700-85ad-11eb-896f-b531e77d0166.PNG">
<h2>Table 전략</h2>
<ul>
  <li>키 생성 전용 테이블을 하나 만들어서 데이터베이스 시퀀스를 흉내내는 전략</li>
  <li>장점: 모든 데이터베이스에 적용 가능</li>
  <li>단점: 성능</li>
</ul>
<pre>
create table MY_SEQUENCES ( 
 sequence_name varchar(255) not null, 
 next_val bigint, 
 primary key ( sequence_name ) 
)
========================================
@Entity 
@TableGenerator(name = "MEMBER_SEQ_GENERATOR", table = "MY_SEQUENCES", pkColumnValue = “MEMBER_SEQ", allocationSize = 1) 
public class Member { 
@Id 
@GeneratedValue(strategy = GenerationType.TABLE, generator = "MEMBER_SEQ_GENERATOR")
private Long id; 
</pre>
<h2>@TableGenerator - 속성</h2>
<img src="https://user-images.githubusercontent.com/76415175/111119951-1cdd4900-85ae-11eb-8f5e-dd224286119e.PNG">
<h2>권장하는 식별자 전략</h2>
<ul>
  <li>기본 키 제약 조건: null 아님, 유일, 변하면 안된다.</li>
  <li>미래까지 이 조건을 만족하는 자연키는 찾기 어렵다. 대리키(대체키)를 사용하자.</li>
  <li>권장: Long형 + 대체키 + 키 생성전략 사용</li>
</ul>
